<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<html>
<style type="text/css">
p{margin-top:0; margin-bottom:0;}
</style>
<body>
<BOLD><h2>Activity: Implementation: Rubber Hits Road</h2>
<p class="textfield" id="creator"><B>Creator</B>Marthin Laubscher</p>
<p class="textfield" id="description"><B>Description </B></p>Implementation is a technical problem, and any technical problem has a solution. What separates "can be solved" from "is solved" is doing the work. This is the concern where we do it.
<br>
<br>For its initial and reference implementation, SSK lives in PostgreSQL user space as a C language extension: a User Defined Type SSK with functions, operators, and a User Defined Aggregate SSK_AGG. Not deeply integrated into the database core, but fully functional.
<br>
<br>The trivial domain implementation is trivial, and that matters. Free of scale's distractions, it focuses entirely on SSK semanticsï¿½transparent and auditable. Every bit in the vector is visible. Every membership decision is clear. Every operation is verifiable with a programmer's calculator. No magic. No black boxes. No ambiguity.
<br>
<br>When we extend to the inevitable non-trivial domain, the trivial implementation stands as a code-level reference. It defines what each function must achieve as it works with the vast abstract bit vector. The semantics remain fixed, solid, regardless of scale.
<br><br>
<h2>Usage List:</h2>
<ul>
<li> Appears as <a href="actuseImplementationCOLON_Rubber_Hits_Road345.html">Implementation: Rubber Hits Road</a>  in Diagram  <a class="diagram" href="dgmDecomposition_of_SSK_Concerns333.html">Decomposition of SSK Concerns</a> in  in  <a class="diagram" href="dgmProject_Concerns24.html">Project Concerns</a>.<br>
</ul>
</body>
</html>
